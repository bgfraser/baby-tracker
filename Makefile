#!/usr/bin/env make
include Makehelp

# Infra Targets

## Build and push gcs-streaming-proxy image. Requires IMAGE_TAG
build: env
	docker-compose run --rm gcloud sh -c 'cd infra/gcs-proxy; gcloud builds submit --substitutions=BRANCH_NAME=${IMAGE_TAG} --config=cloudbuild.yaml'
.PHONY: build

## Deploy Cloudrun revision. Requires GCP_PROJECT_ID and IMAGE_TAG
deploy: env
	docker-compose run --rm gcloud sh -c 'gcloud run deploy gcs-proxy --image gcr.io/learn-prd/gcs-streaming-proxy:${IMAGE_TAG} --project ${GCP_PROJECT_ID} --region australia-southeast1 --platform managed'
.PHONY: deploy

## Initialise Terraform
tfinit: env
	docker-compose run --rm envvars ensure --tags terraform-init
	docker-compose run --rm terraform-utils sh -c 'cd ${TERRAFORM_ROOT_MODULE}; terraform init'
.PHONY: tfinit

## Initialise Terraform but also upgrade modules/providers
tfupgrade: env tfinit
	docker-compose run --rm envvars ensure --tags terraform-init
	docker-compose run --rm terraform-utils sh -c 'cd ${TERRAFORM_ROOT_MODULE}; terraform init -upgrade'
.PHONY: tfupgrade

## Generate a plan
tfplan: env tfinit 
	docker-compose run --rm envvars ensure --tags terraform
	docker-compose run --rm terraform-utils sh -c 'cd ${TERRAFORM_ROOT_MODULE}; terraform plan'
.PHONY: tfplan

## Generate a plan and save it to the root of the repository. This should be used by CICD systems
tfplanAuto: env tfinit 
	docker-compose run --rm envvars ensure --tags terraform
	docker-compose run --rm terraform-utils sh -c 'cd ${TERRAFORM_ROOT_MODULE}; terraform plan -out ../${TERRAFORM_ROOT_MODULE}.tfplan'
.PHONY: tfplanAuto

## Generate a plan and apply it
tfapply: env tfinit 
	docker-compose run --rm envvars ensure --tags terraform
	docker-compose run --rm terraform-utils sh -c 'cd ${TERRAFORM_ROOT_MODULE}; terraform apply'
.PHONY: tfapply

## Apply the plan generated by planAuto. This should be used by CICD systems
tfapplyAuto: env tfinit 
	docker-compose run --rm envvars ensure --tags terraform
	docker-compose run --rm terraform-utils sh -c 'cd ${TERRAFORM_ROOT_MODULE}; terraform apply -auto-approve ../${TERRAFORM_ROOT_MODULE}.tfplan'
.PHONY: tfapplyAuto

## Destroy resources
tfdestroy: env tfinit 
	docker-compose run --rm envvars ensure --tags terraform
	docker-compose run --rm terraform-utils sh -c 'cd ${TERRAFORM_ROOT_MODULE}; terraform destroy'
.PHONY: tfdestroy

## Show the statefile
tfshow: env tfinit 
	docker-compose run --rm envvars ensure --tags terraform
	docker-compose run --rm terraform-utils sh -c 'cd ${TERRAFORM_ROOT_MODULE}; terraform show'
.PHONY: tfshow

## Show root module outputs
tfoutput: env tfinit 
	docker-compose run --rm envvars ensure --tags terraform
	docker-compose run --rm terraform-utils sh -c 'cd ${TERRAFORM_ROOT_MODULE}; terraform output'
.PHONY: tfoutput

## Validate terraform is syntactically correct
tfvalidate: env tfinit
	docker-compose run --rm envvars ensure --tags terraform
	docker-compose run --rm terraform-utils sh -c 'cd ${TERRAFORM_ROOT_MODULE}; terraform validate'
.PHONY: tfvalidate

## Format all Terraform files
tfformat: env
	docker-compose run --rm terraform-utils terraform fmt -diff -recursive
.PHONY: tfformat

## Interacticely launch a shell in the Terraform docker container
tfshell: env
	docker-compose run --rm terraform-utils sh
.PHONY: tfshell

## Generate Docker env file
env:
	touch .env
	docker-compose run --rm envvars validate
	docker-compose run --rm envvars envfile --overwrite
.PHONY: env
